[[techover]]
= Tech Overview

Spring Integration provides an intuitive programming model for complex enterprise integration strategies. These Integration strategies are adopted in asynchronous, message-driven style while being loosly coupled for modularity and testability. The goal here, much like Spring Framework itself, enforces separation of concerns between business and integration logic. Thus adoption among existing Spring users means they can rely on the same style and abstract nature that help to promote reusability and portability across projects. Spring Integration's design is indeed a blend of both these common patterns within Spring, and the patterns described in Enterprise Integration Patterns, by Gregor Hohpe and Bobby Woolf (Addison Wesley, 2004). 

Architectural facilities that promote loose coupling are the interfaces defining the contracts between layers of abstraction. For example, messaging systems typically follow the similarly abstract "pipes-and-filters" model.  Whereas "filters" represent components that produce or consume messages, whereas the "pipes" represent components that transport messages between filters.  Thus the underlaying infrastructure supporting "pipes" are programmed as a set of interfaces having 'input/output', 'read/write' semantics. Similarly, the "filters" must be programmed in a way that issues 'input/output' semantic over an application's service layer interfaces in much the same way a web or socket tier would.

== Message

Data is important amongst all components of any program. Thus in an Integration solution, it is the 'Message'. This is a wrapper for both any object which consists of an application payload, and it's headers. Headers are used to communicate intention between connected transports. This metadata lets the application transport or direct a message to it's downstream terminus. For example, if a message is an email, then header will contain the properties (from, to, subject, etc..) that are used in the sending of the message at the mail exchanger. Furthermore, the composition of message-headers is really up to the ultimate use of the application; developers can store any arbitrary key/value pairs there. One may even store a userId in the header as a way to authenticate a message's route through various transports. We will focus more on metadata and metadata strategies later in this book.

.A message composition diagram.
image::{code}/techover/the-message.png[alt=The Message]

The Message Channel concept enables transmission of messages from producers to consumers. This constitues the "pipe" of our pipes-and-filters architecture. Consumers retrieve messages from a particular Message Channel, thus providing a convenient place for certain actions to be performed on the messages after it's producer has sent it to the channel, and before the consumer has received it.

.A message channel diagram.
image::{code}/techover/the-message-channel.png[alt=The Message Channel]

Message Channels have 2 behaviors: "Point-to-point" and "Publish-Subscribe" that specify how consumers receive a message. The Point-to-Point channel specifies that no more than one consumer may receive a message sent to the channel. Publish-subscribe (also known as Pubsub) channels, will allow a 'fan-out' approach whereas any number of consumers may receive the message.

Channels should behave according to design of the capacity of inductance toward consumers. That is, a channel may or may not 
buffer messages sent across it. Buffering implies a 'queue'
structure underneath the channel allowing the consumer to 'poll' or periodically check for additional messages. The advantage here
is that a consumer may opt to consume as many as can be handled - prevention of memory and network preassure. This works well for point-to-point channels. On the other hand, because we may not want to store messages in the channel, but rather issue them as fast as possible is more of a publish-subscribe symantic. The Integration platform itself doesnt know how messages line up with channels; it is up to the developer to logically align channels with the endpoints
that will receive messages. This is all to say that Channels are indeed the logical 'address' of a message-driven system. Because of this, it is only intuition that says channels are referenced with names like 'qa-mail-out' and 'qa-file-in' - basically these names by which the operator can control (by clearing, reloading or some other action) and ensure proper system-wide operation.

We will discuss in depth the varieties of message channel implementations, but for now understand that channels provide the message-driven abstraction layer above transport to which a subscriber may participate.

== Message Endpoints

Spring Integration simplifies the composition of messaging based software. That is, because messaging is a means to connect heterogeneus systems together, the overall architecture of an Integration takes into focus the disparate domains in which each system is built on. Spring Integration gives a declarative approach to configuration in this setting, and allows you to "connect" the domain-specific code to the messaging infrastructure provided by Spring Integration. Thus, the components being connected to these messaging infrastructure are called messaging endpoints. The most important influence within this kind of architecture is the sperartion-of-concern between integration logic, and business logic. Basically, as with MVC, we dont rely on the actual server to the job, but usually a set of external domain-focus systems. Messaging makes getting data in and out of these domain focused systems not only intuitive but resiliant and predictable.

== Host of Endpoint Variants

The following list shows the main kinds of message endpoints supported by Spring Integration out of the box:

=== Transformer

A Transformer converts the message content or structure. Think of a user identity manager which turns a username/password pair into a User of that system. Similarly, a transformer can modify the message's header values.

=== Filter

Filters simply allows or disallows a message to pass through the channel. This implies a boolean test method that check message state for determining conditions of acceptance. If the message is accepted, it goes along to the output channel. In the other case, a Filter may drop, or throw Exception.

[NOTE]
====
Be careful not to confuse the generic use of “filter” within the pipes-and-filters architectural pattern with this specific endpoint type that selectively narrows down the messages flowing between two channels. The pipes-and-filters concept of a “filter” matches more closely with Spring Integration’s message endpoint: any component that can be connected to a message channel in order to send or receive messages.
====

=== Router 

This component can determine which channel to send a particular message based on its content. Message router can be equated to a static output channel configured with a service activator or another endpoint capable of a 'reply' message.

=== Splitter

Splitters can break an incoming message into multiple messages and send them to the appropriate channel(s). This is typically used for decomposing messages into discreet elements consumable in the output channel. An example is turning a String into a series of Chars.

=== Aggregator

Like Splitter in reverse, this component combines multiple messages into one. An aggregator is more complex than a splitter and is often required to maintain state. In case aggregation reaches time limits - timeout - a strategy can be employed that determines how partial aggregates are handled.

=== Service activator

The Service Activator is the interface between the message channel and a service instance, many times containing the application code for business logic. Service activators make 'reply' an option since each message can provide a 'Return Address' header in the absense of output channel. 

.Service Activator
image::{code}/techover/the-service-activator.png[alt=The Service Activator]

=== Channel adapter

Is used to connect the message channel to another system or transport. Usually a Channel Adapter makes the leap between protocol boundaries and does mapping to bind the two sides. This for example
can be something like converting an HTTP request to SMTP, or maybe
Files to JMS message. Spring Integration provides a host of Channel Adapter implementations for popular technologies. This endpoint also comes in 2 flavours - Inbound and Outbound.

.Inbound Adapter
image::{code}/techover/inbound-channel-adapter.png[alt=Inbound Channel Adapter]

The Inbound adapter may be a static resource such as file system. In this case, new file arrivals can trigger the adapter to Stringify and send file contents as a Message on the programmed output channels.

.Outbound Adapter
image::{code}/techover/outbound-channel-adapter.png[alt=Outbound Channel Adapter]

The direction of message flow is reverse of Inbound Adapter. Outbound adapters will typically consume a message, then transform it into a protocol the adapter is binding to. For example a message may arrive with filename as a header property, so that the adapter writes the message as a file to the filesystem.

== Summary

Each of these message endpoints encapsulate the semantics of the Integration pattern it is named after, and will be reviewed in greater detail LATER IN THIS BOOK. 

In the next chapter, we will tackle the vital configuration aspects  that help us assemble a functional application. Later, we will begin diving into the concrete implementation details for each of the listed components. Using Spring Boot and Spring Integration together has never been more delightful.