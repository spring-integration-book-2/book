[[Channels]]
= Message Channels

Message Channels represent the virtual data pipe that connects two or more endpoints. It is generalized to think of this as connective logic to an endpoint in 2 modes: sender and receiver.
The message channel decouples the sender and receiver so that the receiver does not know who sent the message and likewise the sender does not know of the message recipient.
Enterprise Integration Patterns breaks channels into two major types: point-to-point channels and publish-subscribe channels. An application developer will select the kinds of channels used 
in order to control the behavior of how messages get sent and received. Thus, Spring Integration simplifies development of message channels with it's implementation of EIP messaging concepts.

== EAI Message Channel Patterns

The message channel design pattern allows a message to hold a piece of information that gets passed between different service components, which can either be in a process or across different applications in different datacenters.
For example, a retail store's inventory system can send a message describing low inventory on a certain item (e.g. 'store:12345','item:99999','count:0') to the corporate warehouse so that it can send more of this deficient item back to the store.
Payloads can be whatever your organization may choose, the messaging channels do not necessarily have to participate in the payload description, however that is an option discussed later in this chapter

The message endpoints are the components that interact with the messages. The endpoint that sends messages to the message channel is called the producer or sender. The receiving endpoint is called the receiver or consumer.
The producer puts data into a message and the receiver takes the data from the message and performs some actions with it. As a result, it is important to align data payloads between channels and endpoints. Aside from standard consumer/producer stereotypes, 
a message endpoint may filter messages within a channel, route messages to other channels, and/or augment the message with additional data (such as authorizations).
In some cases, it may be needed to provide long term aggregation and short term splitting logic. The former consumes messages until some condition is met in which a summary gets sent to the receiving channel, whereas the latter
can split a message into multiple messages and route them into different channels.

The message channel connects the endpoints together. Messages are produced and sent to be received by one or more consumers depending on the type of channel.
The channel ensures that the messages can be sent and received between endpoints in a manner consistent with application needs. Sometimes this means that a channel 
stores messages into an internal long-term storage block such as a database or even persistent queue. Since it is application data that is encapsulated within the message, the channel does not need to understand
payload. In other words, the message channel design pattern is meant to decouple the producer from the consumer.

In order to make interaction between endpoints intuitive to the developer, each message channel has a unique string label, making each channel appear as a logical address.
Enterprise Integration Patterns describe serveral different kinds of channels that have a variety of effects with regards to message handling. We will take a look at these in the next sections.

=== Point-to-Point Channel

A point-to-point channel (see Figure ###) ensures that there is only one consumer that receives the same message from the sender at any given time. Spring Integration provides several types of point-to-point channel implementations:
`QueueChannel`, `PriorityChannel`, `RendezvousChannel`, `DirectChannel`, `ExecutorChannel`, and `NullChannel`.

.Point-to-Point Channel
image::{code}/channels/point-to-point.png[alt=The Point to Point Channel]

=== Publish-Subscribe Channel

The publish-subscribe channel (see Figurre ###) allows one-to-many relationship between the producer
and consumer, such that multiple consumers may receive the same message. The message is marked as
“received” and removed from the channel when all the subscribed receivers have consumed the
message. Publish-Subscribe implementation may even have a 'fire-and-forget' semantic which means there could
be no one listening to the message that was sent. Spring Integration currently provides a publish-subscribe–style message channel
implementation, which is PublishSubscribeChannel. 

.Publish-subscribe Channel
image::{code}/channels/publish-subscribe.png[alt=The Publish Subscribe]

=== Data-Typed Channel

Applications can use the message channel to transfer different types of data between the message producer and consumer. In order to process the message correctly,
consumers need to have knowledge about the message payload data type. The consumer needs to determine the object type in order to apply proper business logic to handle the message.
Usually, this means hinting the consumer with a header that indicates the data type. This translates into a scenario where producer sends object type A and type B through the same channel.

However, a consumer may only be able to process one type of data. Such a processor for example may only take type A, while anoanother can take type B.
A message channel that only contains single type of objects or messages is called a data-typed channel. This approcach solves the problem of breaking
down data types by router or filter and allows a direct 1:1 relationship for producer-channel and consume-channel.
An example of a channel that can handle different data types of data, and a `data-type` channel is shown in figure ###.

.Data-Typed Channel
image::{code}/channels/data-typed.png[alt=The Data Typed Channel]

=== Invalid Message Channel

A message may not be processable by a message processor, or it fails validation for some reason - perhaps it is an object C of which only A and B are recognized.
This message will then get routed into the invalid message channel (see Figure ###), allowing further handling by the other processors/application components. 
In Spring Integration, the validation would be done by a message filter, which is discussed more in depth in Chapter ###.

.Invalid Message Channel
image::{code}/channels/invalid.png[alt=The Invalid Message Channel]

=== Dead Letter Channel

When an application fails to deliver a message to the channel after all retry attempts, the message will be sent to the dead letter channel and will be handled further by another process or application listening for messages on that channel (see Figure ###).

.Dead Letter Channel
image::{code}/channels/dead-letter.png[alt=The Dead Letter Channel]

=== Channel Adapter

A channel adapter is a message endpoint that allows an integration application to connect externally with messaging semantics. Spring Integration providesfor a variety of channel adapters that bind to transports such as JMS, HTTP, SMTP, FileSystem and others.
Additionally, Channel Adapters come in two modes: in-bound and out-bound for consuming and producing externally bound messages respectively. By using a common interface or application programming interface(API), applications can be easily integrated with 
external systems.

.Channel Adapter
image::{code}/channels/channel-adapter.png[alt=The Channel Adapter]

=== Messaging bridge

The messaging bridge allows a channel to take the characteristics of another channel. For example, the developer may want to connect a `PollableChannel` to a `SubscribableChannel` so that the subscribing endpoints don't have to worry about polling configuration. Instead, the messaging bridge provides the polling support. Messaging bridges can simplify the setup 
of application data transformations across system boundaries by including a transformer with the in/out channel of a bridge configuration.

.Messaging Bridge
image::{code}/channels/messaging-bridge.png[alt=The Messaging Bridge]

=== Guaranteed delivery

Messages are normally stored in memory and wait for delivery by the messaging system. If the message system crashes, all the messages will be lost. In order to guarantee the delivery, the messaging system can use a data store to persist the messages. By default, all the Spring Integration channels store messages in memory. However, message channels cna be backed by a JMS broker, which in turn stores messages in that broker's persistence store instead of application memory.
Message channels are just another strategy interface and can be tailored to your specific needs as required; implementations can be built that delegate to any data store conceivable using the `MessageStore` interface or - for more control - by implementing the `MessageChannel` interface itself.

== Choosing a Spring Integration Channel Implementation

All Spring Integration message channels implement the `org.springframework.messaging.MessageChannel` interface as shown below. This interface defines how a producer sends a message to the channel. This is required since different types of message channel implementations operate in different ways. Depending on the type of message channel implementation, the send operation can block indefinitely or for a given timeout until the message is received.

.MessageChannel.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/MessageChannel.java[]
----

As hinted upon earlier, Spring Integration applies message channel design in two implementations based on established EIP pattern principles: 
`org.springframework.messaging.PollableChannel` and `org.springframework.messaging.SubscribableChannel`. Both of the implementations are unique subinterfaces of the `MessageChannel` interface.

`PollableChannel` (see listing ###) defines a receiver that periodically poll for messages from the channel. The consumer can choose to wait indefinitely or for a given timeout until a message arrives.

.PollableChannel.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/PollableChannel.java[]
----

The alternative way to receive messages is by using the `SubscribableChannel`, which allows the sender to push the message to 0 or more subscribed receivers. When the sender sends a message, the subscribed receiver(s) will receive the message and process it by the provided `org.springframework.messaging.MessageHandler`. Once a message has been sent to the channel, all subscribed message handlers will be invoked.

.SubscribableChannel.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/SubscribableChannel.java[]
----

The `MessageHandler` interface contains only one method, which will handle the pushed messages from the `SubscribableChannel` channel. The interface also throws `org.springframework.messaging.MessagingException` depending on the message channel implementation, each exception may be handled differently (such as failover and retry). As a result, it is always a good idea to throw the appropriate exception for the given cause.

.MessageHandler.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/MessageHandler.java[]
----

=== Point-to-Point Channel

Spring Integration provides several different implementations of the point-to-point channel pattern. Lets look at the different point-to-point channel options.

==== QueueChannel

The `QueueChannel` class is the simplest implementation of the `MessageChannel` interface. `QueueChannel` has point-to-point semanteics. In other words, even if the channel has multiple consumers, only one of them will receive any message sent to that channel. `QueueChannel` also provides a mechanism to fiter and purge messages that satisfy certain criteria. Additionally, `QueueChannel` stores all messages in memory since it wraps a queue internally. 
By default, `QueueChannel` can use all the available memory to store messages. To avoid running out of memory, `QueueChannel` provides a constructor that accepts the queue capacity.

By specifying a message limit, the sender may block until room is available in the queue. Alternately, you can specify a timout parameter on the `send(Message)` method to 

==== DirectChannel

The channel implementation considered 'default' is the `org.springframework.integration.channel.DirectChannel` - a mixture of point-to-point and publish-subscribe channels. It uses the publish-subscribe pattern so the message will be pushed to the consumer, but only one consumer can receive the same message at any given time. As a result, `DirectChannel` is actually a point-to-point channel.
Figure ### shows a comprehensive class hierarchy of the subclasses of `MessageChannel` that compose `DirectChannel`.

.Direct Channel Class Diagram
image::{code}/channels/DirectChannelClassDiagram.png[alt=Direct Channel Class Diagram]

==== PriorityChannel

==== RendezvousChannel

==== ExecutorChannel

=== Publish-SubScribe Channel

==== SubscribableChannel

==== PublishSubscribeChannel

=== FluxMessageChannel

=== ScopedChannel

== Channel Interceptors

== MessagingTemplate

== Configuring Message Channels
