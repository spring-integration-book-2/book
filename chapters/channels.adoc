[[Channels]]
= Message Channels

Message Channels represent the virtual data pipe that connects two or more endpoints. It is generalized to think of this as connective logic to an endpoint in 2 modes: sender and receiver.
The message channel decouples the sender and receiver so that the receiver does not know who sent the message and likewise the sender does not know of the message recipient.
Enterprise Integration Patterns breaks channels into two major types: point-to-point channels and publish-subscribe channels. An application developer will select the kinds of channels used 
in order to control the behavior of how messages get sent and received. Thus, Spring Integration simplifies development of message channels with it's implementation of EIP messaging concepts.

== EAI Message Channel Patterns

The message channel design pattern allows a message to hold a piece of information that gets passed between different service components, which can either be in a process or across different applications in different datacenters.
For example, a retail store's inventory system can send a message describing low inventory on a certain item (e.g. 'store:12345','item:99999','count:0') to the corporate warehouse so that it can send more of this deficient item back to the store.
Payloads can be whatever your organization may choose, the messaging channels do not necessarily have to participate in the payload description, however that is an option discussed later in this chapter

The message endpoints are the components that interact with the messages. The endpoint that sends messages to the message channel is called the producer or sender. The receiving endpoint is called the receiver or consumer.
The producer puts data into a message and the receiver takes the data from the message and performs some actions with it. As a result, it is important to align data payloads between channels and endpoints. Aside from standard consumer/producer stereotypes, 
a message endpoint may filter messages within a channel, route messages to other channels, and/or augment the message with additional data (such as authorizations).
In some cases, it may be needed to provide long term aggregation and short term splitting logic. The former consumes messages until some condition is met in which a summary gets sent to the receiving channel, whereas the latter
can split a message into multiple messages and route them into different channels.

The message channel connects the endpoints together. Messages are produced and sent to be received by one or more consumers depending on the type of channel.
The channel ensures that the messages can be sent and received between endpoints in a manner consistent with application needs. Sometimes this means that a channel 
stores messages into an internal long-term storage block such as a database or even persistent queue. Since it is application data that is encapsulated within the message, the channel does not need to understand
payload. In other words, the message channel design pattern is meant to decouple the producer from the consumer.

In order to make interaction between endpoints intuitive to the developer, each message channel has a unique string label, making each channel appear as a logical address.
Enterprise Integration Patterns describe serveral different kinds of channels that have a variety of effects with regards to message handling. We will take a look at these in the next sections.

=== Point-to-Point Channel

A point-to-point channel (see Figure $$$) ensures that there is only one consumer that receives the same message from the sender at any given time. Spring Integration provides several types of point-to-point channel implementations:
`QueueChannel`, `PriorityChannel`, `RendezvousChannel`, `DirectChannel`, `ExecutorChannel`, and `NullChannel`.

.Point-to-Point Channel
image::{code}/channels/point-to-point.png[alt=The Point to Point Channel]

=== Publish-Subscribe Channel

The publish-subscribe channel (see Figurre $$$) allows one-to-many relationship between the producer
and consumer, such that multiple consumers may receive the same message. The message is marked as
“received” and removed from the channel when all the subscribed receivers have consumed the
message. Publish-Subscribe implementation may even have a 'fire-and-forget' semantic which means there could
be no one listening to the message that was sent. Spring Integration currently provides a publish-subscribe–style message channel
implementation, which is PublishSubscribeChannel. 

.Publish-subscribe Channel
image::{code}/channels/publish-subscribe.png[alt=The Publish Subscribe]

=== Data-Typed Channel

Applications can use the message channel to transfer different types of data between the message producer and consumer. In order to process the message correctly,
consumers need to have knowledge about the message payload data type. The consumer needs to determine the object type in order to apply proper business logic to handle the message.
Usually, this means hinting the consumer with a header that indicates the data type. This translates into a scenario where producer sends object type A and type B through the same channel.

However, a consumer may only be able to process one type of data. Such a processor for example may only take type A, while anoanother can take type B.
A message channel that only contains single type of objects or messages is called a data-typed channel. This approcach solves the problem of breaking
down data types by router or filter and allows a direct 1:1 relationship for producer-channel and consume-channel.
An example of a channel that can handle different data types of data, and a `data-type` channel is shown in figure $$$.

.Data-Typed Channel
image::{code}/channels/data-typed.png[alt=The Data Typed Channel]

=== Invalid Message Channel

A message may not be processable by a message processor, or it fails validation for some reason - perhaps it is an object C of which only A and B are recognized.
This message will then get routed into the invalid message channel (see Figure $$$), allowing further handling by the other processors/application components. 
In Spring Integration, the validation would be done by a message filter, which is discussed more in depth in Chapter $$$.

.Invalid Message Channel
image::{code}/channels/invalid.png[alt=The Invalid Message Channel]

=== Dead Letter Channel

When an application fails to deliver a message to the channel after all retry attempts, the message will be sent to the dead letter channel and will be handled further by another process or application listening for messages on that channel (see Figure $$$).

.Dead Letter Channel
image::{code}/channels/dead-letter.png[alt=The Dead Letter Channel]

=== Channel Adapter

A channel adapter is a message endpoint that allows an integration application to connect externally with messaging semantics. Spring Integration providesfor a variety of channel adapters that bind to transports such as JMS, HTTP, SMTP, FileSystem and others.
Additionally, Channel Adapters come in two modes: in-bound and out-bound for consuming and producing externally bound messages respectively. By using a common interface or application programming interface(API), applications can be easily integrated with 
external systems.

.Channel Adapter
image::{code}/channels/channel-adapter.png[alt=The Channel Adapter]

=== Messaging bridge

The messaging bridge allows a channel to take the characteristics of another channel. For example, the developer may want to connect a `PollableChannel` to a `SubscribableChannel` so that the subscribing endpoints don't have to worry about polling configuration. Instead, the messaging bridge provides the polling support. Messaging bridges can simplify the setup 
of application data transformations across system boundaries by including a transformer with the in/out channel of a bridge configuration.

.Messaging Bridge
image::{code}/channels/messaging-bridge.png[alt=The Messaging Bridge]

=== Guaranteed delivery

Messages are normally stored in memory and wait for delivery by the messaging system. If the message system crashes, all the messages will be lost. In order to guarantee the delivery, the messaging system can use a data store to persist the messages. By default, all the Spring Integration channels store messages in memory. However, message channels cna be backed by a JMS broker, which in turn stores messages in that broker's persistence store instead of application memory.
Message channels are just another strategy interface and can be tailored to your specific needs as required; implementations can be built that delegate to any data store conceivable using the `MessageStore` interface or - for more control - by implementing the `MessageChannel` interface itself.

== Choosing a Spring Integration Channel Implementation

All Spring Integration message channels implement the `org.springframework.messaging.MessageChannel` interface as shown below. This interface defines how a producer sends a message to the channel. This is required since different types of message channel implementations operate in different ways. Depending on the type of message channel implementation, the send operation can block indefinitely or for a given timeout until the message is received.

.MessageChannel.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/MessageChannel.java[]
----

As hinted upon earlier, Spring Integration applies message channel design in two implementations based on established EIP pattern principles: 
`org.springframework.messaging.PollableChannel` and `org.springframework.messaging.SubscribableChannel`. Both of the implementations are unique subinterfaces of the `MessageChannel` interface.

`PollableChannel` (see listing $$$) defines a receiver that periodically poll for messages from the channel. The consumer can choose to wait indefinitely or for a given timeout until a message arrives.

.PollableChannel.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/PollableChannel.java[]
----

The alternative way to receive messages is by using the `SubscribableChannel`, which allows the sender to push the message to 0 or more subscribed receivers. When the sender sends a message, the subscribed receiver(s) will receive the message and process it by the provided `org.springframework.messaging.MessageHandler`. Once a message has been sent to the channel, all subscribed message handlers will be invoked.

.SubscribableChannel.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/SubscribableChannel.java[]
----

The `MessageHandler` interface contains only one method, which will handle the pushed messages from the `SubscribableChannel` channel. The interface also throws `org.springframework.messaging.MessagingException` depending on the message channel implementation, each exception may be handled differently (such as failover and retry). As a result, it is always a good idea to throw the appropriate exception for the given cause.

.MessageHandler.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/MessageHandler.java[]
----

=== Publish-SubScribe Channel

The `PublishSubscribeChannel` implementation is the basic publish-subscribe (PubSub) channel implementation. This message channel broadcasts any sent messages to all of the channel subscribers. In addition, the messages are pushed to the consumers instead of the consumers polling for the messages. Rather than provide a `receive()` method, the publish-subscribe channel pushes it's messages directly to any `MessageHandler`s.
The channel has a behaviour of sending messages to subscribers only when a `minSubscribers` threshold (0 or more) is set.

.PublishSubscribe Channel Class Diagram
image::{code}/channels/PublishSubscribeChannelClassDiagram.png[alt=PubSub Channel Class Diagram]

=== Point-to-Point Channel

Spring Integration provides several different implementations of the point-to-point channel pattern. Lets look at the different point-to-point channel options.

==== QueueChannel

The `QueueChannel` class is the simplest implementation of the `MessageChannel` interface. `QueueChannel` has point-to-point semanteics. In other words, even if the channel has multiple consumers, only one of them will receive any message sent to that channel. `QueueChannel` also provides a mechanism to fiter and purge messages that satisfy certain criteria. Additionally, `QueueChannel` stores all messages in memory since it wraps a queue internally. 
By default, `QueueChannel` can use all the available memory to store messages. To avoid running out of memory, `QueueChannel` provides a constructor that accepts the queue capacity.

.QueueChannel.java
[source,java,indent=0]
----
include::{code}/channels/src/main/java/tdgsi/channels/QueueChannel.java[]
----

By specifying a message limit, the sender may block until room is available in the queue. Alternately, you can specify a timout parameter on the `send(Message)` method so that the call may block until capacity is available on the queue or the timeout occurs.
The `QueueChannel` implements a `receive()` method which returns immediately when a message is already waiting on the internal queue, or will block until one is ready for consumption. This behaviour can be altered by using the overloaded `receive()` method with timeout parameter. Specifying a timeout value 0 will cause the `receive()` method to return immediately if no message is available.

.QueueChannel Class Diagram
image::{code}/channelsQueueChannelClassDiagram.png[alt=Queue Channel Class Diagram]

==== PriorityChannel

The PriorityChannel exhibits the same holding behaviour as the QueueChannel with the additional behaviour of ordering messages thus giving one message 'priority' over another. In order to achieve this, the `PriorityChannel` uses a `Comparator` to compute message order. By default, this order is obtained from 
the message header key `priority`. The PriorityChannel provides a constructor that takes a `Comparator<Message>` argument to allow custom comparasion logic.

.Priority Channel Class Diagram
image::{code}/channels/PriorityChannelClassDiagram.png[alt=Priority Channel Class Diagram]

==== RendezvousChannel

The `RendezvousChannel` is a synchronized version of the `QUeueChannel`. It uses a zero-capacity `SynchronousQueue` instead of `BlockingQueue` internally. The sender will be blocked until the receiver receives the message from the channel. In other words, the sender cannot send the next message until the receiver retrieves the current message from the channel; or, the receiver will block until the sender sends a message to `RendezvousChannel`. The behavior is
similar to a semaphore running in multiple trheads; as a result, it is useful to use `RendesvousChannel` to synchronize multiple threads when semaphores are not an option.

.Rendezvous Channel Class Diagram
image::{code}/channels/RendezvousChannelClassDiagram.png[alt=Rendezvous Channel Class Diagram]

One particularly interesting use case for `RendezvousChannel` is request-reply.  By constructing a RendezvousChannel and setting it's ID as a 'replyChannel' message header on a message being sent, the sender can call `receive` in order to block (and possibly timeout) while waiting for a reply. Spring Integration makes use of this pattern in order to apply request-reply semantics to some components.

.Rendezvous RequestReply Diagram
image::{code}/channels/RendezvousRequestReplyDiagram.png[alt=Rendezvous Request Reply Diagram]

==== DirectChannel

The channel implementation considered 'default' - and the simplest - is the `org.springframework.integration.channel.DirectChannel` - a mixture of point-to-point and publish-subscribe channels. It uses the publish-subscribe pattern so the message will be pushed to the consumer, but only one consumer can receive the same message at any given time. As a result, `DirectChannel` is actually a point-to-point channel.
The `DirectChannel` allows for a single thread to perform both sides of the channel operation - that is send and receive - in which the `MessageHandler` will invoke `handleMessage(Message)` method directly on the sender thread, before the `send()` method can return. This allows for transactions to occur across channels while still being loose coupled to the messaging system. In this way, a `send()` call within the scope of a transaction will have it's outcome determined
by the outcome of the MessageHandler's `handleMessage(Message)` method. 

Figure $$$ shows a comprehensive class hierarchy of the subclasses of `MessageChannel` that compose `DirectChannel`.

.Direct Channel Class Diagram
image::{code}/channels/DirectChannelClassDiagram.png[alt=Direct Channel Class Diagram]

==== ExecutorChannel

Similar to `DirectChannel`, `org.springframework.integration.channel.ExecutorChannel` is a point-to-point message channel. However, it allows the dispatching to happen in an instance of `java.util.concurrent.Executor` in a thread separate from the sender thread.
Because of this, the send method of `ExecutorChannel` will not be blocked and as a result, `ExecutorChannel` does not support transactions that span the sender and receiving `MessageHandler` as does `DirectChannel`.

.Executor Channel Class Diagram
image::{code}/channels/ExecutorChannelClassDiagram.png[alt=Executor Channel Class Diagram]

==== Point-to-Point Load-Balancing Strategies

=== Scope Binding a Channel

In order to restrict a message channel the same `scope` as define in an instance of `org.springframework.beans.factory.config.Scope`, the developer can define a channel scope attribute that applies to that channel.
A common use case is to bind a channel to the current thread. This channel delegates to a queue internally like a QueueChannel, but the channel (as well as the internal queue) is bound to the current thread. By defining the channel scope attribute, no other thread will be able to access a message within the thread-scoped message channel.

.Common Channel Scopes
image::{code}/channels/ScopesDiagram.png[alt=Common Channel Scopes]

=== NullChannel

This channel implementation behaves like '/dev/null' in traditional POSIX systems. The `NullChannel` is very interesting - it is a dummy message channel that does nothing. It does not pass any message from the sender to the receiver. `NullChannel`'s send method always returns true, while it's receive() method always returns a `null` value. In other words, `NullChannel` always returns 
success when attempting to send, while the channel always appears to contain nothing during reception. Due to the special behavior of `NullChannel`, it is mainly used for unit testing, intgration testing, and debugging.

.Null Channel Class Diagram
image::{code}/channels/NullChannelClassDiagram.png[alt=Null Channel Class Diagram]

The `NullChannel` is defined within the application context by default along with an `errorChannel`. The channel logs any messages sento to it with DEBUG level.

=== Point-to-Point Exercise

Here we will take a small sample of each of our point-to-point implementations as part of a business use-case.
*** Add Formalized Example Entry ***

=== FluxMessageChannel

This reactive `FluxMessageChannel` should be used to bridge Reactive streams into Integration workflows. This channel does not implement either of the two Spring Integration MessageChannel subclasses `SubscribableChannel` or `PollableChannel` meaning one must 
use this only in conjunction with other `FluxMessageChannel` or as to bridge a `org.reactivestreams.Publisher` with the Integration Flow.

.FluxMessageChannel Class Diagram
image::{code}/channels/FluxMessageChannelDiagram.png[alt=Flux Message Channel Class Diagram]

== Channel Interceptors

Spring Integration provides the ability to intercept the messages at specific stages around the `MessageChannel`'s send and receive operations. This is where the `ChannelInteceptor` interface comes into play.
This interface allows the message to be intercepted - much like AOP - before and after it is sent and/or received WITHOUT error, and finally as a completion phase whether or not an exception has occured.
The following graphs depicts the stages of a message channel where an interceptor perofrms each of it's methods.

.ChannelInteceptor Interception Diagram
image::{code}/channels/ChannelInteceptorDiagram.png[alt=ChannelInteceptor Diagram]

Since only the `PollableChannel` interface has the receive operation, `preReceive` and `postReceive` will be invoked only for `PolalbleChannel` implementations. The different available interceptor methods for the various message channesls are shown in Table $$$.

.Table $$$. Message Channels and Interceptors
image::{code}/channels/ChannelInteceptorInteractionDiagram.png[alt=ChannelInteceptor Interaction Diagram]

One example of how this works in practice is the `WireTap` inteceptor that binds to a channel being operated on. This interceptor sends each passing message onto another `wiretap` channel as each message passes through the bound channel.
This channel logs each message and is good for debugging testing and monitoring.

=== Global Interceptors

Spring Integration allows interceptors to be registered and applied to dynamically registered channels - such as at the time of definition through one of the DSL definitions or `beanFactory` initialized beans.

== MessagingTemplate

Spring Integration provides `MessagingTemplate` as a very easy way to integrate a messaging system into applications. It supports common message channel operations, such as send and receive. `MessagingTemplate` can support transactions by providing a `PlatformTransactionManager`. Additionally, The `MessagingTemplate` can build Spring Integration `Message` instances.

== Configuring Message Channels

== Channel persistence

== Summary

Spring Integration is inspired by `Enterprise Integration Patterns`. This chapter has looked at how Spring Integration implements the message channel pattern. By providing various implementations of the point-to-point message channel and publish-subscribe channels, applications can communicate by sending message with each other in a non-invasive manner. The message operations can be shared in multiple threads, or only exist on the local thread.